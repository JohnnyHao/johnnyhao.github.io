

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>React-Native 乾坤大罗移之 调用原生方法 | React全栈研究</title>
  <meta name="author" content="johnnyhao">
  
  <meta name="description" content="有时候我们的App需要访问平台API，并且React Native可能还没有相应的模块包装；或者你需要复用一些Java代码，而不是用Javascript重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。而用React Native可以在它的基础上编写真正原生的代码，并且可以访问平台所有的能力。如果React Native还不支持某个你需要的原生特性，你应当可以自己实现该特性的封装。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="React-Native 乾坤大罗移之 调用原生方法"/>
  <meta property="og:site_name" content="React全栈研究"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="React全栈研究" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
</head>


<body>
  <header id="header" class="inner">
<div class="alignleft">
  <h1><a href="/">React全栈研究</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
      <li><a href="/tools">工具</a></li>
    
	<li> <a href="/atom.xml">RSS</a> </li>
<li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>

  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-21T02:35:38.000Z"><a href="/2016/04/21/4-2/">2016-04-21</a></time>
      
      
  
    <h1 class="title">React-Native 乾坤大罗移之 调用原生方法</h1>
  

    </header>
    <div class="entry">
      
        <p>有时候我们的App需要访问平台API，并且React Native可能还没有相应的模块包装；或者你需要复用一些Java代码，而不是用Javascript重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。<br>而用React Native可以在它的基础上编写真正原生的代码，并且可以访问平台所有的能力。如果React Native还不支持某个你需要的原生特性，你应当可以自己实现该特性的封装。</p>
<a id="more"></a>
<p>不过在开始编写代码使用原生模块前，有一个知识点需要掌握，免得又坑进去了。</p>
<p>在使用React Native的时候，经常会看到这么一段代码</p>
<p>var React = require(‘react-native’);</p>
<p>那么require这个语句的作用到底是什么呢，下面的流程提取自require() 源码解读</p>
<p>当遇到 require(X) 时，按下面的顺序处理</p>
<ol>
<li>如果 X 是内置模块（比如 require(‘http’）)<br>　　a. 返回该模块。<br>　　b. 不再继续执行。
　　</li>
<li><p>如果 X 以 “./” 或者 “/” 或者 “../” 开头<br>a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br> X<br> X.js<br> X.json<br> X.node</p>
</li>
<li><p>将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</p>
<p> X/package.json（main字段）<br> X/index.js<br> X/index.json<br> X/index.node    </p>
</li>
<li><p>如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</p>
</li>
<li>抛出 “not found”</li>
</ol>
<p>以上就是require语句的整个执行过程。那么require(‘react-native’);请求的到底是什么呢，其实就是node_modules\react-native\Libraries\react-native\react-native.js这个文件，该文件中导出了一些常用的组件，其源码如下</p>
<pre><code>
/**
* Copyright (c) 2015-present, Facebook, Inc.
* All rights reserved.
*
* This source code is licensed under the BSD-style license found in the
* LICENSE file in the root directory of this source tree. An additional grant
* of patent rights can be found in the PATENTS file in the same directory.
*
* @flow
*/
'use strict';

// Export React, plus some native additions.
//
// The use of Object.create/assign is to work around a Flow bug (#6560135).
// Once that is fixed, change this back to
//
//  var ReactNative = {...require('React'), /* additions */}
//
var ReactNative = Object.assign(Object.create(require('React')), {
  // Components
  ActivityIndicatorIOS: require('ActivityIndicatorIOS'),
  DatePickerIOS: require('DatePickerIOS'),
  DrawerLayoutAndroid: require('DrawerLayoutAndroid'),
  Image: require('Image'),
  ListView: require('ListView'),
  MapView: require('MapView'),
  Modal: require('Modal'),
  Navigator: require('Navigator'),
  NavigatorIOS: require('NavigatorIOS'),
  PickerIOS: require('PickerIOS'),
  ProgressBarAndroid: require('ProgressBarAndroid'),
  ProgressViewIOS: require('ProgressViewIOS'),
  ScrollView: require('ScrollView'),
  SegmentedControlIOS: require('SegmentedControlIOS'),
  SliderIOS: require('SliderIOS'),
  SnapshotViewIOS: require('SnapshotViewIOS'),
  Switch: require('Switch'),
  SwitchAndroid: require('SwitchAndroid'),
  SwitchIOS: require('SwitchIOS'),
  TabBarIOS: require('TabBarIOS'),
  Text: require('Text'),
  TextInput: require('TextInput'),
  ToastAndroid: require('ToastAndroid'),
  ToolbarAndroid: require('ToolbarAndroid'),
  TouchableHighlight: require('TouchableHighlight'),
  TouchableNativeFeedback: require('TouchableNativeFeedback'),
  TouchableOpacity: require('TouchableOpacity'),
  TouchableWithoutFeedback: require('TouchableWithoutFeedback'),
  View: require('View'),
  ViewPagerAndroid: require('ViewPagerAndroid'),
  WebView: require('WebView'),

  // APIs
  ActionSheetIOS: require('ActionSheetIOS'),
  AdSupportIOS: require('AdSupportIOS'),
  AlertIOS: require('AlertIOS'),
  Animated: require('Animated'),
  AppRegistry: require('AppRegistry'),
  AppStateIOS: require('AppStateIOS'),
  AsyncStorage: require('AsyncStorage'),
  BackAndroid: require('BackAndroid'),
  CameraRoll: require('CameraRoll'),
  Dimensions: require('Dimensions'),
  Easing: require('Easing'),
  ImagePickerIOS: require('ImagePickerIOS'),
  InteractionManager: require('InteractionManager'),
  LayoutAnimation: require('LayoutAnimation'),
  LinkingIOS: require('LinkingIOS'),
  NetInfo: require('NetInfo'),
  PanResponder: require('PanResponder'),
  PixelRatio: require('PixelRatio'),
  PushNotificationIOS: require('PushNotificationIOS'),
  Settings: require('Settings'),
  StatusBarIOS: require('StatusBarIOS'),
  StyleSheet: require('StyleSheet'),
  VibrationIOS: require('VibrationIOS'),

  // Plugins
  DeviceEventEmitter: require('RCTDeviceEventEmitter'),
  NativeAppEventEmitter: require('RCTNativeAppEventEmitter'),
  NativeModules: require('NativeModules'),
  Platform: require('Platform'),
  processColor: require('processColor'),
  requireNativeComponent: require('requireNativeComponent'),

  // Prop Types
  EdgeInsetsPropType: require('EdgeInsetsPropType'),
  PointPropType: require('PointPropType'),

  // See http://facebook.github.io/react/docs/addons.html
  addons: {
    LinkedStateMixin: require('LinkedStateMixin'),
    Perf: undefined,
    PureRenderMixin: require('ReactComponentWithPureRenderMixin'),
    TestModule: require('NativeModules').TestModule,
    TestUtils: undefined,
    batchedUpdates: require('ReactUpdates').batchedUpdates,
    cloneWithProps: require('cloneWithProps'),
    createFragment: require('ReactFragment').create,
    update: require('update'),
  },
});

if (__DEV__) {
  ReactNative.addons.Perf = require('ReactDefaultPerf');
  ReactNative.addons.TestUtils = require('ReactTestUtils');
}

module.exports = ReactNative;

</code></pre>


<p>了解了这个知识点后，我们来自定义一个模块，去使用原生的模块。假设有这么一个需求，我们需要使用Andorid中的Log类，但是React Native并没有为我们进行封装，那么我们自己动手实现一下吧。</p>
<ul>
<li><p>我们需要继承ReactContextBaseJavaModule这个抽象类，重写getName()函数，用于返回一个字符串，这个字符串在JavaScript端标记这个模块，暴露一个函数给javascript端，并且使用注解@ReactMethod进行标记，该函数的返回值必须为void，React Native的跨语言访问是异步进行的，所以想要给JavaScript返回一个值的唯一办法是使用回调函数或者发送事件。</p>
</li>
<li><p>我们需要实现一个类实现ReactPackage接口，该接口中有三个抽象函数待实现，分别是createNativeModules，createJSModules，createViewManagers，这三个函数中，我们需要实现的最关键的函数就是createNativeModules，在该函数中我们需要添加前一步创建的ReactContextBaseJavaModule子类</p>
</li>
<li><p>构建ReactInstanceManager的实例时，通过调用 addPackage()函数，将上一步实现的ReactPackage添加进去。</p>
</li>
</ul>
<p>接下来我们来实现代码。为了简单方便，这里只演示Log类中的d方法，即Log.d(String tag,String msg)</p>
<p>第一步，继承ReactContextBaseJavaModule类，重写getName()方法，因为是Log模块，所以直接返回字符串Log，暴露一个d方法给javascript端，返回值为void，只用注解进行标记。最终的代码如下。</p>
<pre><code>
public class LogModule extends ReactContextBaseJavaModule{
    private static final String MODULE_NAME="Log";

    public LogModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    @Override
    public String getName() {
        return MODULE_NAME;
    }

    @ReactMethod
    public void d(String tag,String msg){
        Log.d(tag,msg);
    }
}
</code></pre>


<p>第二步，实现ReactPackage接口，在createNativeModules函数中添加我们的日志模块。其余两个函数返回空的List即可。</p>
<pre><code>
public class AppReactPackage implements ReactPackage {
    @Override
    public List<nativemodule> createNativeModules(ReactApplicationContext reactContext) {
        List<nativemodule> modules=new ArrayList<>();
        modules.add(new LogModule(reactContext));
        return modules;
    }

    @Override
    public List<class<? extends="" javascriptmodule="">> createJSModules() {
        return Collections.emptyList();
    }

    @Override
    public List<viewmanager> createViewManagers(ReactApplicationContext reactContext) {
        return Collections.emptyList();
    }
}

</viewmanager></class<?></nativemodule></nativemodule></code></pre>




<p>第三步，添加AppReactPackage 到ReactInstanceManager的实例中去，在我们的MainActivity中可以看到这么一段代码</p>
<pre><code>
mReactInstanceManager = ReactInstanceManager.builder()
                .setApplication(getApplication())
                .setBundleAssetName("index.android.bundle")
                .setJSMainModuleName("index.android")
                .addPackage(new MainReactPackage())
                .setUseDeveloperSupport(BuildConfig.DEBUG)
                .setInitialLifecycleState(LifecycleState.RESUMED)
                .build();

</code></pre>

<p>我们再build函数之前调用addPackage进行添加即可，最终代码如下。</p>
<pre><code>
mReactInstanceManager = ReactInstanceManager.builder()
                .setApplication(getApplication())
                .setBundleAssetName("index.android.bundle")
                .setJSMainModuleName("index.android")
                .addPackage(new MainReactPackage())
                .addPackage(new AppReactPackage())
                .setUseDeveloperSupport(BuildConfig.DEBUG)
                .setInitialLifecycleState(LifecycleState.RESUMED)
                .build();

</code></pre>



<p>可以看到我们增加了一行.addPackage(new AppReactPackage())</p>
<p>这样，在Java端我们要做的就做完了，接下来就是javascript端了，这时候编译一下apk重新后运行，接下来我们来编写javascript端。</p>
<p>如果你不嫌麻烦，每次都要从NativeModules来访问我们的Log，那么现在你可以直接在javascript中进行访问了。就像这样子。</p>
<pre><code>
var React = require('react-native');

var {
  NativeModules,
} = React;

var Log1= NativeModules.Log;

Log1.d("Log1","LOG");
</code></pre>


<p>但是，假如我再增加一个需求，就是当Log类在java层打印出一个日志的之后，希望在js端也输出以下这个日志，那么你会怎么做呢，或许你会说，这个简单，我再输出一下js的日志就ok了。就像这样子。</p>
<pre><code>
var React = require('react-native');

var {
  NativeModules,
} = React;

var Log1= NativeModules.Log;

Log1.d("Log1","LOG");
console("Log1","LOG");
</code></pre>



<p>没错是没错，就是看着蛋疼，不好维护不说，通样的代码你得写多少遍。</p>
<p>这时候，我们就有必要封装一下javascript端的代码了，在index.android.js文件同目录下新建一个log.js，输入如下代码。</p>
<pre><code>
'use strict';
var { NativeModules } = require('react-native');

var RCTLog= NativeModules.Log;

var Log = {
  d: function (
    tag: string,
    msg: string
  ): void {
    console.log(tag,msg);
    RCTLog.d(tag, msg);
  },
};

module.exports = Log;
</code></pre>



<p>代码很简单，我们通过NativeModules拿到我们的Log模块在本地的实现，赋值给变量RCTLog，并且还声明了一个Log变量，里面有 一个函数d，调用了RCTLog的d函数，并且在调用前输出了javascript端的日志。最后使用module.exports=Log将Log变量 导出</p>
<p>上面我们规定了参数类型为string，java与javascript之间参数类型的对应关系如下</p>
<pre><code>
Boolean -> Bool
Integer -> Number
Double -> Number
Float -> Number
String -> String
Callback -> function
ReadableMap -> Object
ReadableArray -> Array
</code></pre>



<p>接下来就是引用log.js文件了，看过上面的require语句的解析，这对你应该不成问题了。</p>
<pre><code>
var Log=require('./log');
Log.d("TAG","111");
</code></pre>

<p>这还没完，我们再提一个需求，就是我们希望这个Log模块能够提供一个常量，也就是TAG供我们使用，而这个常量定义在java层，以便以后我们使用的时候如果不想输入TAG，可以直接使用这个默认的TAG，就像这样子</p>
<pre><code>
var Log=require('./log');
Log.d(Log.TAG,"111");
</code></pre>



<p>那么这个要怎么实现呢，很显然，我们需要在log.js中加入这个变量，就像这样子</p>
<pre><code>
'use strict';


var { NativeModules } = require('react-native');

var RCTLog= NativeModules.Log;
var Log = {
  TAG: RCTLog.TAG,
  d: function (
    tag: string,
    msg: string
  ): void {
    console.log(tag,msg);
    RCTLog.d(tag, msg);
  },
};

module.exports = Log;
</code></pre>



<p>这样虽然我们可以使用Log.TAG返回到这个值了，由于我们java层没有定义TAG，所以这时候会报错。因此我们需要在java层返回这个值，这又要怎么做呢，别急。我们重新回过头来看看我们实现的类LogModule，我们继续在该类中定义两个常量</p>
<pre><code>
private static final String TAG_KEY = "TAG";
private static final String TAG_VALUE = "LogModule";
</code></pre>


<p>什么用呢，看常量名字就是到了，key和value，键值对，我们希望通过TAG_KEY拿到TAG_VALUE ，也就是我们日志要用到的TAG，怎么实现呢。重写getConstants函数即可。</p>
<pre><code>
  @Override
    public Map<string, object=""> getConstants() {
        final Map<string, object=""> constants = MapBuilder.newHashMap();
        constants.put(TAG_KEY, TAG_VALUE);
        return constants;
    }
</string,></string,></code></pre>



<p>这时候重写编译运行一下，你就可以在javascript层通过Log.TAG就可以访问到对应的值了，值为LogModule，而为什么是Log.TAG而不是其他的值呢，因为我们constants中put进去的键就是TAG。</p>
<p>那么这个有什么作用呢，还记得android中我们的Toast的使用，显示时间有两个值吗，一个是Toast.LENGTH_SHORT，另一个是Toast.LENGTH_LONG，我们希望在javascript层通用有这么两个常量可以使用，那么就可以使用这种方法。我们可以看看系统的ToastAndroid的实现。</p>
<p>首先看java层</p>
<pre><code>
public class ToastModule extends ReactContextBaseJavaModule {

  private static final String DURATION_SHORT_KEY = "SHORT";
  private static final String DURATION_LONG_KEY = "LONG";

  public ToastModule(ReactApplicationContext reactContext) {
    super(reactContext);
  }

  @Override
  public String getName() {
    return "ToastAndroid";
  }

  @Override
  public Map<string, object=""> getConstants() {
    final Map<string, object=""> constants = MapBuilder.newHashMap();
    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);
    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);
    return constants;
  }

  @ReactMethod
  public void show(String message, int duration) {
    Toast.makeText(getReactApplicationContext(), message, duration).show();
  }
}
</string,></string,></code></pre>




<p>看到没有，在getConstants函数中暴露了两个值给javascript层，SHORT对应java层的Toast.LENGTH_SHORT，LONG对应java层的Toast.LENGTH_LONG。接着看javascript层的代码</p>
<pre><code>
'use strict';

var RCTToastAndroid = require('NativeModules').ToastAndroid;

var ToastAndroid = {

  SHORT: RCTToastAndroid.SHORT,
  LONG: RCTToastAndroid.LONG,

  show: function (
    message: string,
    duration: number
  ): void {
    RCTToastAndroid.show(message+"lizhangqu", duration);
  },

};

module.exports = ToastAndroid;
</code></pre>



<p>直接可以通过定义的变量SHORT或者LONG访问到，最终我们的使用就是这样子的。</p>
<pre><code>
var React = require('react-native');
var {
  ToastAndroid
} = React;
ToastAndroid.show("toast",ToastAndroid.SHORT);
</code></pre>


<p>这还没完，这仅仅是没有返回值的情况，假如有返回值情况又是怎么样呢，比如javascript调用java层的方法，但是java层需要将结果返回javascript，没错，答案就是回调！，最典型的一个场景就是javascript层调用java层的网络请求方法，java层拿到网络数据后需要将结果返回给javascript层。通用的，我们用最快的速度实现一下这个模块。</p>
<p>继承ReactContextBaseJavaModule，实现getName方法，返回值为Net，暴露一个getResult方法给javascript，并进行注解，注意这个函数有一个Callback类型的入参，返回结果就是通过这个进行回调</p>
<pre><code>
public class NetModule extends ReactContextBaseJavaModule {
    private static final String MODULE_NAME="Net";
    public NetModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    @Override
    public String getName() {
        return MODULE_NAME;
    }

    @ReactMethod
    public void getResult(String url,final Callback callback){
        Log.e("TAG","正在请求数据");
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {

                    String result="这是结果";
                    Thread.sleep(1000);//模拟网络请求
                    callback.invoke(true,result);
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }
        }).start();


    }
}



Callback的定义如下，它是一个接口，invoke函数的入参是个数是任意的。


public interface Callback {

  /**
  * Schedule javascript function execution represented by this {@link Callback} instance
  *
  * @param args arguments passed to javascript callback method via bridge
  */
  public void invoke(Object... args);

}
</code></pre>



<p>在前面的AppReactPackage类createNativeModules函数中注册该模块</p>
<pre><code>

modules.add(new NetModule(reactContext));

</code></pre>



<p>之后新建一个net.js文件，实现javascript层</p>
<pre><code>
'use strict';
var { NativeModules } = require('react-native');

var RCTNet= NativeModules.Net;

var Net = {

  getResult: function (
    url: string,
    callback:Function,
  ): void {
    RCTNet.getResult(url,callback);
  },
};

module.exports = Net;
</code></pre>



<p>进行使用</p>
<pre><code>
var Net=require('./net');
Net.getResult(
    "http://baidu.com",
    (code,result)=>{
        console.log("callback",code,result);
    }
);
</code></pre>



<p>如果不出意外，在java层将输出日志</p>
<p>11-20 22:30:53.598 25323-1478/com.awesomeproject E/TAG: 正在请求数据</p>
<p>在javascript层，控制台将输出</p>
<p>callback true 这是结果</p>
<p>以上就是回调的一个示例，你可以简单想象成java层的网络请求模型，主线程开启子线程请求数据，子线程拿到数据后回调对应的方法使用handler通知主线程返回结果。</p>
<p>除了回调之外，还可以使用事件调用javascript层的方法，我们以第一个LogModule为例，假设调用了java层方法后，我们希望发送一个事件给javascript，在javascript层再次进行打印输出。则d方法修改下面的代码</p>
<pre><code>
@ReactMethod
    public void d(String tag,String msg){
        Log.d(tag, msg);
        //发送事件给javascript层
        WritableMap params = Arguments.createMap();
        params.putString("TAG",tag);
        params.putString("MSG",msg);
        getReactApplicationContext()
                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                .emit("logInConsole", params);//对应的javascript层的事件名为logInConsole，注册该事件即可进行回调

    }
</code></pre>


<p>而对应的log.js并不需要做什么修改，我们只需要在想获得该事件的地方注册事件即可，比如我们想在主界面接收该事件，则在index.android.js中进行注册，注册的方式有两种。</p>
<p>第一种如下</p>
<pre><code>
'use strict';

var React = require('react-native');

var {
  AppRegistry,
  StyleSheet,
  View,
  DeviceEventEmitter,
} = React;


//注意下面两个模块的引入
var Log=require('./log');
var Subscribable = require('Subscribable');

var AwesomeProject = React.createClass({
  mixins: [Subscribable.Mixin],//这句必须要加
  render: function() {
    return (
    <view style="{styles.container}">
  </view>
    );
  },
  componentDidMount:function(){
    Log.d("tag","tag");//调用java层log方法，之后就会回调对应的事件（前提是注册了事件）
    //注册事件
    this.addListenerOn(DeviceEventEmitter,
                      'logInConsole',
                      this.logInConsole);
  },
  logInConsole:function(event){
    console.log(event);
  },
});

var styles = StyleSheet.create({
  container:{

  },
});


AppRegistry.registerComponent('AwesomeProject', () => AwesomeProject);
</code></pre>



<p>这种方式显得代码有点多，还有另外一种方式，代码如下</p>
<pre><code>
'use strict';

var React = require('react-native');
var {
  AppRegistry,
  StyleSheet,
  View,
  DeviceEventEmitter,
} = React;

//只需要引入Log
var Log=require('./log');
var AwesomeProject = React.createClass({

  render: function() {
    return (
    <view style="{styles.container}">
  </view>
    );
  },
  componentDidMount:function(){
    Log.d("tag","tag");//调用java层log方法，之后就会回调对应的事件（前提是注册了事件）
    //直接使用DeviceEventEmitter进行事件注册
    DeviceEventEmitter.addListener('logInConsole',(e)=>{
      console.log(e);
    });

  },
});

var styles = StyleSheet.create({
  container:{
  },
});
AppRegistry.registerComponent('AwesomeProject', () => AwesomeProject);

</code></pre>


<p>效果是一样的。都会在控制台输出。</p>
<p>基本上，掌握了上面的内容，对原始模块的使用也差不多了，本篇文章是基于官方文档的最佳实践Native Modules，但是官方文档坑太多，还需谨慎参考，自己多多尝试。</p>

      
    </div>
    <footer>
      
        
        
<!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare">
<a class="bds_qzone"></a>
<a class="bds_tsina"></a>
<a class="bds_tqq"></a>
<a class="bds_renren"></a>
<a class="bds_t163"></a>
<span class="bds_more"></span>
<a class="shareCount"></a>
</div>
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=3326447" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



 <nav id="pagination" >
    
    <a href="/2016/04/25/hello-world/" class="alignleft prev" >Prev</a>
    
    
    <div class="clearfix"></div>
</nav>



<section id="comment">

<!-- Duoshuo Comment BEGIN -->
	<div class="ds-thread"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"zippera"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- Duoshuo Comment END -->  

  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜一下">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  <div class="widget tag">
<h3 class="title">简介</h3>
<ul class="entry">
<li>姓名：Johnny.hao</li>
<li>二次元：浩皓|Tonny </li>
<li>现状：全栈研发</li>
<li>QQ号：422673012</li>
<li>微信: hbcyzw</li>

</ul>
</div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><section>
Theme of <a href="https://github.com/zippera/lightum">Lightum</a>, Improved from <a href="https://github.com/hexojs/hexo-theme-light">Light</a>, by <a href="/">zippera</a> 
</section>
<div class="clearfix"></div>
</footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>


<a href="https://github.com/zippera" target="_blank"><img style="position: absolute; top: 0; left: 0; border: 0;" src="/img/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>
